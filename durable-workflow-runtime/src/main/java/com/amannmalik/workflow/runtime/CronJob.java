package com.amannmalik.workflow.runtime;

import com.cronutils.model.definition.CronDefinitionBuilder;
import com.cronutils.model.time.ExecutionTime;
import com.cronutils.parser.CronParser;
import dev.restate.common.Request;
import dev.restate.common.Target;
import dev.restate.sdk.ObjectContext;
import dev.restate.sdk.SharedObjectContext;
import dev.restate.sdk.annotation.Handler;
import dev.restate.sdk.annotation.Name;
import dev.restate.sdk.annotation.Shared;
import dev.restate.sdk.annotation.VirtualObject;
import dev.restate.sdk.common.StateKey;
import dev.restate.sdk.common.TerminalException;
import dev.restate.serde.TypeTag;
import io.serverlessworkflow.api.types.Workflow;

import java.time.ZonedDateTime;
import java.util.Optional;

import static com.cronutils.model.CronType.UNIX;

@Name("CronJob")
@VirtualObject
public class CronJob {

    private final StateKey<JobInfo> JOB_STATE = StateKey.of("job-state", JobInfo.class);
    private final CronParser PARSER =
            new CronParser(CronDefinitionBuilder.instanceDefinitionFor(UNIX));

    @Handler
    public JobInfo initiate(ObjectContext ctx, JobRequest request) {
        if (ctx.get(JOB_STATE).isPresent()) {
            throw new TerminalException("Job already exists for this ID");
        }
        return scheduleNextExecution(ctx, request);
    }

    @Handler
    public void execute(ObjectContext ctx) {
        JobRequest request =
                ctx.get(JOB_STATE).orElseThrow(() -> new TerminalException("Job not found")).request();

        executeTask(ctx, request);
        scheduleNextExecution(ctx, request);
    }

    @Handler
    public void cancel(ObjectContext ctx) {
        ctx.get(JOB_STATE)
                .ifPresent(jobState -> ctx.invocationHandle(jobState.nextExecutionId()).cancel());

        // Clear the job state
        ctx.clearAll();
    }

    @Shared
    public Optional<JobInfo> getInfo(SharedObjectContext ctx) {
        return ctx.get(JOB_STATE);
    }

    private void executeTask(ObjectContext ctx, JobRequest job) {
        Target target =
                (job.key().isPresent())
                        ? Target.virtualObject(job.service(), job.method(), job.key().get())
                        : Target.service(job.service(), job.method());
        var request =
                (job.workflow().isPresent())
                        ? Request.of(
                        target,
                        TypeTag.of(Workflow.class),
                        TypeTag.of(Void.class),
                        job.workflow().get())
                        : (job.payload().isPresent())
                        ? Request.of(
                        target,
                        TypeTag.of(String.class),
                        TypeTag.of(Void.class),
                        job.payload().get())
                        : Request.of(target, new byte[0]);
        ctx.send(request);
    }

    private JobInfo scheduleNextExecution(ObjectContext ctx, JobRequest request) {
        // Parse cron expression
        ExecutionTime executionTime;
        try {
            executionTime = ExecutionTime.forCron(PARSER.parse(request.cronExpression()));
        } catch (IllegalArgumentException e) {
            throw new TerminalException("Invalid cron expression: " + e.getMessage());
        }

        // Calculate next execution time
        var now = ctx.run(ZonedDateTime.class, ZonedDateTime::now);
        var delay =
                executionTime
                        .timeToNextExecution(now)
                        .orElseThrow(() -> new TerminalException("Cannot determine next execution time"));
        var next =
                executionTime
                        .nextExecution(now)
                        .orElseThrow(() -> new TerminalException("Cannot determine next execution time"));

        // Schedule next execution for this job
        String thisJobId = ctx.key(); // This got generated by the CronJobInitiator
        Target target = Target.virtualObject("CronJob", thisJobId, "execute");
        var handle = ctx.send(Request.of(target, TypeTag.of(JobRequest.class), TypeTag.of(JobInfo.class), request), delay);

        // Save job state
        var jobState = new JobInfo(request, next.toString(), handle.invocationId());
        ctx.set(JOB_STATE, jobState);
        return jobState;
    }
}
